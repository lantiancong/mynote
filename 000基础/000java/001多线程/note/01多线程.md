## 线程,进程,多线程

main线程(对应main函数),gc线程(垃圾回收线程)

## 继承Thread类

Thread类已继承了Runnable接口

![1](..\img\1-1.png)

> 继承Thread类
> 重写run()方法

![1](..\img\1-2.png)

> 进入主函数
> 有run()先run
> start()是和主线程交替执行

![1](..\img\1-3.png)

### 下载网图

先装驱动, 使用FileUtils类中的copyURLToFile()方法实现一个下载器

![1](..\img\1-4.png)

## 实现Runnable接口

重写run方法

![1](..\img\1-5.png)

对比(详)

![1](..\img\1-6.png)



![1](..\img\1-7.png)

## 线程状态

02状态笔记

## 线程优先级

![1](..\img\1-8.png)

优先级高并不是先执行,而是资源更多,更可能先执行

## 守护(deamon)线程

thread.setDeamon(true/false)



## 锁机制(synchronized)

### 线程不安全案例

[this](https://www.bilibili.com/video/BV1V4411p7EF?t=728.2&p=19)

![1](..\img\1-9.png)

以下是两个案例(分别是没加锁和加锁的)

```java
package com.lan;

public class UnsafeBank {
    public static void main(String[] args) {
        Account account=new Account(100,"基金");
        Thread wo=new Drawing(account,50,"我");
        Thread girl=new Drawing(account,100,"女朋友");

        wo.start();
        girl.start();
    }
}

class Account{
    int money;
    String name;
    public Account(int money, String name) {
        this.money = money;
        this.name = name;
    }
}

class Drawing extends Thread{
    Account account;
    int drawMoney;
    int nowMoney;

    public Drawing(Account account, int drawMoney,String name) {
        super(name);
        this.account = account;
        this.drawMoney = drawMoney;
    }

    @Override
    public void run() {
        if(account.money<drawMoney){
            System.out.println("钱不够");
            return ;
        }
        try {
            Thread.sleep(1000 );
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        account.money-=drawMoney;

        nowMoney += drawMoney;
        System.out.println("账户余额"+account.money);
        System.out.println(Thread.currentThread().getName()+ "手里有"+nowMoney);
    }
}//不安全
```

加锁

```java
package com.lan;

public class UnsafeBank {
    public static void main(String[] args) {
        Account account=new Account(100,"基金");
        Thread wo=new Drawing(account,50,"我");
        Thread girl=new Drawing(account,100,"女朋友");

        wo.start();
        girl.start();
    }
}

class Account{
    int money;
    String name;
    public Account(int money, String name) {
        this.money = money;
        this.name = name;
    }
}

class Drawing extends Thread{
    Account account;
    int drawMoney;
    int nowMoney;

    public Drawing(Account account, int drawMoney,String name) {
        super(name);
        this.account = account;
        this.drawMoney = drawMoney;
    }

    @Override
    public void run() {
        
        //*******锁在这里********
        synchronized(account){
            if(account.money<drawMoney){
                System.out.println("钱不够");
                return ;
            }
            try {
                Thread.sleep(1000 );
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }

            account.money-=drawMoney;

            nowMoney += drawMoney;
            System.out.println("账户余额"+account.money);
            System.out.println(Thread.currentThread().getName()+ "手里有"+nowMoney);
        }
    }
}
```

## 死锁

```java
//***补充代码







```

## Lock锁

显示锁   / /??

![1](..\img\1-10.png)

## 生产者消费者



## 线程池